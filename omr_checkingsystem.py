# -*- coding: utf-8 -*-
"""OMR_CheckingSystem

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wR1ISDonIHTV9NrLRvs4Nuq9Bw_sFeI_
"""

!pip install opencv-python

import cv2

import numpy as np

path="/content/WhatsApp Image 2023-05-20 at 13.58.14.jpg"

from google.colab.patches import cv2_imshow



widthImg=700
heightImg=700

questions=5
choices=5
ans=[1,2,0,1,4]
img=cv2.imread(path)
img=cv2.resize(img,(widthImg,heightImg))
imgContours=img.copy()
imgBiggestContours=img.copy()
imgFinal=img.copy()


gray= cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
blurred= cv2.GaussianBlur(gray, (5,5), 1)
imgCanny= cv2.Canny(blurred, 10, 50)
contours,hierarchy= cv2.findContours(imgCanny, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
cv2.drawContours(imgContours,contours,-1,(0,255,0),10)

cv2_imshow(imgContours)

def rectCountour (coutours):
  rectCon= []
  for i in coutours:
    area= cv2.contourArea(i) #print("Area", area)
    if area>50:
      peri = cv2.arcLength(i,True)
      approx = cv2.approxPolyDP(i ,0.02*peri, True)
      #print("Corner Points" len(approx))
      if len(approx)==4:
        rectCon.append(i)
  rectCon = sorted (rectCon,key=cv2.contourArea,reverse=True)
  return rectCon

def getCornerPoints(cont):
  peri = cv2.arcLength(cont,True)
  approx = cv2.approxPolyDP(cont ,0.02*peri, True)
  return approx

#FIND RECTANGLES

rectCon = rectCountour(contours)
biggestContour= getCornerPoints(rectCon[0])
gradePoints= getCornerPoints (rectCon[1])

print (biggestContour)

if biggestContour.size != 0 and gradePoints.size!= 0:
  cv2.drawContours (imgBiggestContours, biggestContour, -1,(0,255,0),10)
  cv2.drawContours (imgBiggestContours, gradePoints, -1, (0, 0, 0),10)

  cv2_imshow(imgBiggestContours)

def reorder(myPoints):

  myPoints = myPoints.reshape((4,2))
  myPointsNew = np.zeros((4,1,2), np.int32)
  add = myPoints.sum(1)
  #print (myPoints)
  #print(add)
  myPointsNew[0]= myPoints[np.argmin (add)] #[ee]
  myPointsNew[3]= myPoints[np.argmax (add)] #[w]
  diff= np.diff(myPoints,axis=1)
  myPointsNew[1]= myPoints [np.argmin (diff)]# [we]
  myPointsNew[2] = myPoints [np.argmax (diff)] # [h, 0]
  #print(diff)
  return(myPointsNew)

reorder(biggestContour)

biggestContour=reorder(biggestContour)
gradePoints=reorder(gradePoints)

pt1=np.float32(biggestContour)
pt2 = np.float32([[0,0],[widthImg ,0],[0,heightImg], [widthImg,heightImg]])
matrix = cv2.getPerspectiveTransform(pt1,pt2)
imgWarpColored=cv2.warpPerspective(img,matrix,(widthImg,heightImg))

ptG1= np.float32(gradePoints)
ptG2 = np.float32([[0, 0], [325, 0], [0, 150], [325, 150]])
matrixG = cv2.getPerspectiveTransform(ptG1,ptG2)
imgGradeDisplay = cv2.warpPerspective (img, matrixG, (325, 150))

cv2_imshow(imgWarpColored)
cv2_imshow(imgGradeDisplay)

#APPLY THRESHOLD

imgWarpGray=cv2.cvtColor(imgWarpColored,cv2.COLOR_BGR2GRAY)
imgThresh=cv2.threshold(imgWarpGray,150,255,cv2.THRESH_BINARY_INV)[-1]

cv2_imshow(imgThresh)

def splitBoxes(img):
  rows = np.vsplit(img,5)
  boxes= []
  for r in rows:
    cols = np.hsplit(r,5)
    for box in cols:
      boxes.append(box)
      #cv2_imshow(box)
  return boxes

boxes = splitBoxes(imgThresh)

#FIND NON ZERO PIXELS VALUE

myPixelVal=np.zeros((questions,choices))
countC=0
countR=0

for image in boxes:
  totalPixels=cv2.countNonZero(image)
  myPixelVal[countR][countC]=totalPixels
  countC +=1
  if countC==choices:
    countR +=1
    countC=0
  #print(myPixelVal)

#FINDING INDEX VALUE OF MARKINGS

myIndex =[]
for x in range(0,questions):
  arr=myPixelVal[x]
  myIndexVal=np.where(arr==np.amax(arr))
  myIndex.append(myIndexVal[0][0])
print(myIndex)

#GRADING

grading=[]
for x in range(0,questions):
  if ans[x] == myIndex[x]:
    grading.append(1)
  else: grading.append(0)

#print(grading)

score = (sum(grading)/questions)*100  #FINAL GRADE
print(score)

def showAnswers (img, myIndex, grading, ans, questions, choices):
  secW= int(img.shape[1]/questions)
  secH = int(img.shape[0]/choices)

  for x in range(0, questions):
    myAns= myIndex[x]
    cX = (myAns*secW)+secW//2
    cY = (x*secH) + secH//2

    if grading[x] ==1:
      myColor= (0,255,0)
    else:
      myColor=(0,0,255)
      correctAns = ans [x]
      cv2.circle(img, ((correctAns*secW)+secW//2, (x*secH)+secH//2), 20,(0,255,0), cv2.FILLED)

    cv2.circle(img, (cX, cY), 50, myColor,cv2.FILLED)
  return img

#DISPLAYING ANSWERS

imgResult=imgWarpColored.copy()
imgResult = showAnswers(imgResult, myIndex, grading, ans, questions, choices)
cv2_imshow(imgResult)

#DISPLAY ANSWERS

imgResult = imgWarpColored.copy()

imgResult=showAnswers (imgResult, myIndex, grading, ans, questions, choices)

imRawDrawing =np.zeros_like(imgWarpColored)

imRawDrawing =showAnswers (imRawDrawing, myIndex, grading, ans, questions, choices)

invMatrix = cv2.getPerspectiveTransform(pt2, pt1)

imgInvWarp = cv2.warpPerspective (imRawDrawing, invMatrix, (widthImg, heightImg))

imgFinal= cv2.addWeighted(imgFinal, 1, imgInvWarp, 1,0)

cv2_imshow(imgFinal)

imgRawGrade = np.zeros_like(imgGradeDisplay)

cv2.putText(imgRawGrade, str(int (score))+"%", (50, 100), cv2.FONT_HERSHEY_COMPLEX ,3 ,(0,255,255),3)
invMatrixG = cv2.getPerspectiveTransform(ptG2, ptG1)
imgInvGradeDisplay = cv2.warpPerspective(imgRawGrade, invMatrixG, (widthImg, heightImg))
imgFinal= cv2.addWeighted(imgFinal, 1, imgInvGradeDisplay, 1,0)
cv2_imshow(imgFinal)